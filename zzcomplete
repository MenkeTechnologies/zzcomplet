#
# Started from zle
# Displays zz-list with manual for the first word on the line
# Pastes output of zz-list into current cursor position
#

setopt localoptions typesetsilent

autoload zz-process-buffer zz-usetty-wrapper zz-list zz-list-input zz-list-draw

local curcontext=":zle:$WIDGET"
local MATCH MBEGIN MEND i

# Prepare output variables for zz-process-buffer
local ZZ_PB_WORDS="" ZZ_PB_WORDS_BEGINNINGS="" ZZ_PB_SPACES=""
local ZZ_PB_SELECTED_WORD="" ZZ_PB_LEFT="" ZZ_PB_RIGHT=""

# Process current buffer
zz-process-buffer "$BUFFER"

# Select command for man
local cmd="$ZZ_PB_WORDS[1]"

local ZZLIST_WRAPPER_BIT=""
zz-usetty-wrapper zz-list-wrapper ${(f)"$( man grep | col -b )"}

#
# Rebuilding buffer
#

integer pos="$CURSOR"
integer size="${#ZZ_PB_WORDS}"
integer newcursor
buf=""

zle kill-buffer

integer i j
for (( i=1; i<=size; i++ )); do
    # Check if we're at (i.e. directly at or after,
    # when after are just spaces) current word
    if [ "$i" = "$ZZ_PB_SELECTED_WORD" ]; then
        # Check if we're at the word itself,
        # or at some distance after it
        if (( pos > (ZZ_PB_WORDS_BEGINNINGS[i] + ${#ZZ_PB_WORDS[i]} - 1) )); then
            # We need to introduce new word
            # First move all words and spaces forward
            for (( j=size; j>=i+1; j-- )); do
                ZZ_PB_WORDS[j+1]="${ZZ_PB_WORDS[j]}"
                ZZ_PB_SPACES[j+1]="${ZZ_PB_SPACES[j]}"
                ZZ_PB_WORDS_BEGINNINGS[j+1]="${ZZ_PB_WORDS_BEGINNINGS[j]}"
            done
            size+=1

            # New word is introduced at position i+1, after current word
            # It doesn't have word beginnings and spaces assigned
            # It has to take spaces from word next to it, i+2
            ZZ_PB_WORDS[i+1]="$ZZLIST_WRAPPER_BIT"
            ZZ_PB_WORDS_BEGINNINGS[i+1]="$pos"

            # Now split spaces
            # cursor_spaces: spaces from current word to the cursor
            integer cursor_spaces=$(( pos - ZZ_PB_WORDS_BEGINNINGS[i] - ${#ZZ_PB_WORDS[i]} + 1 ))
            # take that from spaces of word "next" in: current NEW next
            integer after_spaces=$(( ZZ_PB_SPACES[i+2] - cursor_spaces ))
            local empty=""
            ZZ_PB_SPACES[i+1]="${(l:cursor_spaces:: :)empty}"
            ZZ_PB_SPACES[i+2]="${(l:after_spaces:: :)empty}"
        else
            ZZ_PB_WORDS[i]="$ZZLIST_WRAPPER_BIT"
        fi
    fi
    buf+="$ZZ_PB_SPACES[i]$ZZ_PB_WORDS[i]"
done

# Append final white spaces
buf+="$ZZ_PB_SPACES[i]"
BUFFER="$buf"

zle redisplay

#BUFFER="After word $ZZ_PB_WORDS[ZZ_PB_SELECTED_WORD] (compared: $pos > $((ZZ_PB_WORDS_BEGINNINGS[i] + ${#ZZ_PB_WORDS[i]} -1)) )"
#BUFFER="In word $ZZ_PB_WORDS[ZZ_PB_SELECTED_WORD] (compared: $pos > $((ZZ_PB_WORDS_BEGINNINGS[i] + ${#ZZ_PB_WORDS[i]} -1)) )"
#BUFFER="Your current word was: $ZZ_PB_WORDS[ZZ_PB_SELECTED_WORD]"
#BUFFER="$buf"
#CURSOR="$newcursor"

# vim:ft=zsh
